#' Convert Downloaded Corpus Data to Arrow Format
#'
#' This function converts downloaded data in RDS format to Arrow format.
#'
#' @param pages_dir The directory where the downloaded data is stored.
#' @param arrow_dir The directory where the converted Arrow data will be stored.
#' @param continue Logical indicating whether to continue from where the conversion was left off.
#' @param delete_arrow_dir Logical indicating whether to delete the existing Arrow directory before conversion.
#' @param verbose Logical indicating whether to display messages.
#' @param dry_run Logical indicating whether to run the function without converting any data. Default is FALSE.
#' @param mc_cores The number of cores to be used for parallel processing. Default is 3.
#'   This is limited by memory requirements.
#'
#' @importFrom parallel mclapply
#' @importFrom pbapply pblapply
#' @importFrom openalexR works2df
#' @importFrom arrow write_dataset
#'
#' @export
corpus_pages_to_arrow <- function(
    pages_dir = file.path(".", "data", "pages"),
    arrow_dir = file.path(".", "data", "corpus"),
    continue = TRUE,
    delete_arrow_dir = FALSE,
    verbose = FALSE,
    dry_run = FALSE,
    mc_cores = 3
    #
    ) {
    if (!dir.exists(pages_dir)) {
        stop("The pages directory does not exist.")
    }

    if (delete_arrow_dir) {
        unlink(
            arrow_dir,
            recursive = TRUE
        )
    }

    if (!dir.exists(arrow_dir)) {
        dir.create(
            path = arrow_dir,
            showWarnings = FALSE,
            recursive = TRUE
        )
    }

    years <- list.dirs(
        path = pages_dir,
        full.names = TRUE,
        recursive = FALSE
    )


    if (continue) {
        years_done <- list.dirs(
            path = arrow_dir,
            full.names = TRUE,
            recursive = FALSE
        )

        years <- years[
            !(
                gsub(
                    x = years,
                    pattern = paste0("^", pages_dir, "/set_publication_year="),
                    replacement = ""
                ) %in% gsub(
                    x = years_done,
                    pattern = paste0("^", arrow_dir, "/publication_year="),
                    replacement = ""
                )
            )
        ]
    }

    if (length(years) == 0) {
        message("All years have been processed.")
        return(invisible())
    }

    if (!dry_run) {
        pbapply::pblapply(
            years,
            function(year) {
                if (verbose) {
                    message("\n     Processing year ", year, " ...\n")
                }
                sets <- list.files(
                    path = year,
                    pattern = "^set_",
                    full.names = TRUE,
                    recursive = TRUE
                )
                data <- parallel::mclapply(
                    sets,
                    function(set) {
                        data <- readRDS(file.path(set)) |>
                            openalexR::works2df(verbose = FALSE)

                        data$author_abbr <- IPBES.R::abbreviate_authors(data)

                        data$set <- set |>
                            basename() |>
                            gsub(pattern = "^set_", replacement = "") |>
                            gsub(pattern = ".rds$", replacement = "")

                        # serialize_arrow(data) |>
                        suppressWarnings({
                            if (is.null(data$id)) {
                                data$id <- as.character(NA)
                            } else {
                                data$id <- as.character(data$id)
                            }
                            if (is.null(data$title)) {
                                data$title <- as.character(NA)
                            } else {
                                data$title <- as.character(data$title)
                            }
                            if (is.null(data$ab)) {
                                data$ab <- as.character(NA)
                            } else {
                                data$ab <- as.character(data$ab)
                            }
                            if (is.null(data$author_abbr)) {
                                data$author_abbr <- as.character(NA)
                            } else {
                                data$author_abbr <- as.character(data$author_abbr)
                            }
                            if (is.null(data$publication_year)) {
                                data$publication_year <- as.character(NA)
                            } else {
                                data$publication_year <- as.integer(data$publication_year)
                            }
                            if (is.null(data$doi)) {
                                data$doi <- as.character(NA)
                            } else {
                                data$doi <- as.character(data$doi)
                            }
                        })

                        author_template <- data.frame(
                            au_id = as.character(NA),
                            au_display_name = as.character(NA),
                            au_orcid = as.character(NA),
                            author_position = as.character(NA),
                            is_corresponding = as.character(NA),
                            au_affiliation_raw = as.character(NA),
                            institution_id = as.character(NA),
                            institution_display_name = as.character(NA),
                            institution_ror = as.character(NA),
                            institution_country_code = as.character(NA),
                            institution_type = as.character(NA),
                            institution_lineage = as.character(NA)
                        )

                        i <- sapply(
                            data$author,
                            function(x) {
                                inherits(x, "logical")
                            }
                        )

                        data$author[i] <- list(author_template)

                        ## Thanks Martin Morgan - https://ropensci.slack.com/archives/C026GCWKC/p1711466000083759?thread_ts=1711463020.971399&cid=C026GCWKC
                        ## what is the 'skeleton' of the original data?
                        lengths <- vapply(data$author, NROW, integer(1))
                        groups <- rep(seq_along(data$author), lengths)
                        ## row bind to a single data.frame...
                        unlisted <- do.call(rbind, data$author)
                        ## transform each column with a single `as.character()`
                        unlisted[] <- lapply(unlisted, as.character)
                        ## recreate original data structure
                        data$author <- split(unlisted, groups)


                        i <- sapply(
                            data$topics, function(x) {
                                inherits(x, "logical")
                            }
                        )

                        topics_template <- data.frame(
                            i = as.character(NA),
                            score = as.numeric(NA),
                            name = as.character(NA),
                            id = as.character(NA),
                            display_name = as.character(NA)
                        )

                        data$topics[i] <- list(topics_template)

                        topic_classes <- lapply(topics_template, class)

                        ## what is the 'skeleton' of the original data?
                        lengths <- vapply(data$topics, NROW, integer(1))
                        groups <- rep(seq_along(data$topics), lengths)
                        ## row bind to a single data.frame...
                        unlisted <- do.call(rbind, data$topics)
                        ## apply approppriate classes to columns
                        column_classes <- vapply(topics_template, class, character(1))
                        unlisted[] <- Map(as, unlisted, column_classes)
                        ## recreate original data structure
                        data$topics <- split(unlisted, groups)

                        data |>
                            arrow::write_dataset(
                                path = arrow_dir,
                                partitioning = c("publication_year", "set"),
                                format = "parquet",
                                existing_data_behavior = "overwrite"
                            )
                    },
                    mc.cores = mc_cores
                )
            }
        ) |>
            invisible()
    }


    pages <- list.dirs(
        path = pages_dir,
        full.names = TRUE,
        recursive = FALSE
    ) |>
        gsub(
            x = years,
            pattern = paste0("^", pages_dir, "/set_publication_year="),
            replacement = ""
        )

    arrow <- list.dirs(
        path = arrow_dir,
        full.names = TRUE,
        recursive = FALSE
    ) |>
        gsub(
            x = years_done,
            pattern = paste0("^", arrow_dir, "/publication_year="),
            replacement = ""
        )



    not_completed <- pages[!(pages %in% arrow)]

    if (length(not_completed) > 0) {
        warning(
            "The following years did not complete successful:\n",
            paste0(not_completed, collapse = "\n"),
            "\nPlease run the function again with the same parameters but\n",
            "'delete_arrow_dir = FALSE, continue = TRUE'"
        )
    } else {
        message("All years have been processed.")
    }

    return(length(not_completed))
}
